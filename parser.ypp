%{
    #include <cstdio>
    #include <cstdlib>

    #include "ast.hpp"
    #include "primitive.hpp"
    #include "symtab.hpp"

    #define YYDEBUG 1

    extern Program_ptr ast;
    int yylex(void);
    void yyerror(const char *);
%}

/* Enables verbose error messages */
/* %error-verbose */
%define parse.error verbose
/** WRITE ME:
 *  - Put all your token definitions here
 *  - Put all your type definitions here
 *  - Put all your precedence/associativity rules here
 */

/* %union {
    classunion_stype* u_classunion; // Use a pointer to classunion_stype
} */

%union {
    std::list<Proc_ptr>* u_proc_list;
    Program* u_program;
    std::list<Decl_ptr>* u_decl_list;
    Proc* u_proc;
    std::list<Stat_ptr>* u_stat_list;
    Procedure_block* u_procedure_block;
    Nested_block* u_nested_block;
    std::list<SymName_ptr>* u_symname_list;
    Decl* u_decl;
    Stat* u_stat;
    std::list<Expr_ptr>* u_expr_list;
    Return_stat* u_return_stat;
    Type* u_type;
    Expr* u_expr;
    Lhs* u_lhs;
    SymName* u_symname;
    Primitive* u_primitive;
    StringPrimitive* u_stringprimitive;

    // a couple of hardcoded types
    char* u_base_charptr;
    int u_base_int;
}

%type <u_expr> PrimaryExpr
%type <u_expr> Expression
%type <u_expr> AdditiveExpr
%type <u_expr> MultiplicativeExpr
%type <u_expr> UnaryExpr
%type <u_expr_list> ArgumentList
%type <u_lhs> Variable

%type <u_program> Program
%type <u_proc_list> ProcedureList
%type <u_proc> Procedure


%token <u_base_charptr> IDENTIFIER
%token <u_base_int> INT_LITERAL
%token <u_base_int> CHAR_LITERAL



%token BOOLEAN CHAR INTEGER STRING INTPTR CHARPTR 
%token IF ELSE WHILE VAR PROCEDURE RETURN NULLTOKEN AND 
%token DIV EQUAL EQUALS GT GTE LT LTE MINUS NOT 
%token NOTEQUAL OR PLUS MUL AMP DEREFERENCE TRUE FALSE 
%token COMMA COLON UMINUS
%token LBRACE RBRACE SEMICOLON LPAREN RPAREN BAR 
%token LBRACKET RBRACKET STRING_LITERAL 

%left OR
%left AND
%left EQUALS NOTEQUAL
%left LT LTE GT GTE
%left PLUS MINUS
%left MUL DIV
%right NOT
%precedence DEREFERENCE
%precedence UMINUS



%%

Program : ProcedureList { 
            $$ = new ProgramImpl($1);
            ast = $$;
            }
        ;

ProcedureList : Procedure { //$$ = new std::list<Proc_ptr>{};
              //  $$->push_front($1);     
              }
              | Procedure ProcedureList {
                    // $$ = $2;
                    // $$->push_front($1);
                }
              ;


Procedure : PROCEDURE IDENTIFIER LPAREN ParamList RPAREN RETURN Type LBRACE Body OptionalReturn RBRACE {
           // $$ = new ProcImpl(NULL, NULL, NULL, NULL);
            }
          ;

ParamList : 
          | Param
          | ParamList SEMICOLON Param
          ;

Param : IDList COLON Type
      ;

IDList : IDENTIFIER
       | IDENTIFIER COMMA IDList
       ;

Body : OptionalProcedures OptionalDeclarations OptionalStatements
     ;

OptionalProcedures :
                   | NestedProcedures
                   ;

NestedProcedures : Procedure
                 | Procedure NestedProcedures
                 ;
OptionalDeclarations : 
                     | Declarations
                     ;

OptionalStatements :
                   | Statements
                   ;

OptionalReturn : 
               | RETURN Expression SEMICOLON
               ;


Block : LBRACE OptionalDeclarations OptionalStatements RBRACE 
      ;


Declarations : VarDeclaration
             | VarDeclaration Declarations
             ;

VarDeclaration : VAR SingleVarDeclaration SEMICOLON
               | VAR MultiVarDeclaration SEMICOLON
               ;

SingleVarDeclaration : IDENTIFIER COLON STRING LBRACKET INT_LITERAL RBRACKET
                     | IDENTIFIER COLON Type 
                     ;

MultiVarDeclaration : IDList COLON Type 
                    | IDList COLON STRING LBRACKET INT_LITERAL RBRACKET
                    ;

Statements : Statement { }
           | Statement Statements { }
           ;

Statement : IDENTIFIER EQUAL Expression SEMICOLON
          | IDENTIFIER EQUAL STRING_LITERAL SEMICOLON
          | IDENTIFIER LBRACKET Expression RBRACKET EQUAL Expression SEMICOLON 
          | IDENTIFIER LBRACKET Expression RBRACKET EQUAL STRING_LITERAL SEMICOLON
          | IF LPAREN Expression RPAREN Block
          | IF LPAREN Expression RPAREN Block ELSE Block
          | WHILE LPAREN Expression RPAREN Block
          | LBRACE Statements RBRACE
          | Block OptionalStatements
          | FunctionCall
          ;

FunctionCall : IDENTIFIER LPAREN ArgumentList RPAREN SEMICOLON { /* Handle function call here */ };

Expression : Expression OR Expression { /* $$ = new Or($1, $3); */  }
           | Expression AND Expression { /* $$ = new And($1, $3); */ }
           | Expression EQUALS Expression { /*  $$ = new Compare($1, $3); */ }
           | Expression NOTEQUAL Expression { /*$$ = new Noteq($1, $3);*/ }
           | Expression LT Expression {/* $$ = new Lt($1, $3); */}
           | Expression LTE Expression {/* $$ = new Lteq($1, $3);*/ }
           | Expression GT Expression {/* $$ = new Gt($1, $3); */}
           | Expression GTE Expression {/* $$ = new Gteq($1, $3);*/ }
           | AdditiveExpr {/* $$ = $1; */}
           ; 


AdditiveExpr : AdditiveExpr PLUS MultiplicativeExpr {/* $$ = new Plus($1, $3); */}
             | AdditiveExpr MINUS MultiplicativeExpr {/* $$ = new Minus($1, $3);*/ }
             | MultiplicativeExpr {/* $$ = $1; */}
             ;

MultiplicativeExpr : MultiplicativeExpr MUL UnaryExpr {/* $$ = new Times($1, $3); */}
                   | MultiplicativeExpr DIV UnaryExpr { /*$$ = new Div($1, $3);*/ }
                   | UnaryExpr {/* $$ = $1;*/ }
                   ;

UnaryExpr : NOT UnaryExpr {/* $$ = new Not($2); */}
          | MINUS UnaryExpr %prec UMINUS { /*$$ = new Uminus($2);*/ }
          | AMP Variable {/* $$ = new AddressOf($2);*/ }
          | DEREFERENCE IDENTIFIER {/* $$ = new Deref(new Ident(new SymName($2))); */}
          | DEREFERENCE Expression {/* $$ = new Deref($2); */}
          | DEREFERENCE IDENTIFIER LBRACKET INT_LITERAL RBRACKET { } // need to do
          | BAR Expression BAR { /*$$ = new AbsoluteValue($2);*/ }
          | PrimaryExpr {/* $$ = $1;*/ }
          ;

Variable : IDENTIFIER 
         | IDENTIFIER LBRACKET Expression RBRACKET 
         ;

PrimaryExpr : IDENTIFIER { /*$$ = new Ident(new SymName($1)); */}
            | INT_LITERAL {/* $$ = new IntLit(new Primitive($1)); */}
            | LPAREN Expression RPAREN {/* $$ = $2;*/}
            | IDENTIFIER LBRACKET Expression RBRACKET { /*$$ = new ArrayAccess(new SymName($1), $3);*/ }
            | CHAR_LITERAL { /*$$ = new CharLit(new Primitive($1));*/ }
            | TRUE {/* $$ = new BoolLit(new Primitive(true)); */}
            | FALSE { /*$$ = new BoolLit(new Primitive(false)); */}
            | NULLTOKEN { } // need to do 
            ;

ArgumentList : 
             | ExpressionArg 
             | ExpressionArg COMMA ArgumentList
             ;

ExpressionArg : ExpressionArg OR ExpressionArg
              | ExpressionArg AND ExpressionArg
              | ExpressionArg EQUALS ExpressionArg
              | ExpressionArg NOTEQUAL ExpressionArg
              | ExpressionArg LT ExpressionArg
              | ExpressionArg LTE ExpressionArg
              | ExpressionArg GT ExpressionArg
              | ExpressionArg GTE ExpressionArg
              | AdditiveExprArg
              ;

AdditiveExprArg : AdditiveExprArg PLUS MultiplicativeExprArg
                | AdditiveExprArg MINUS MultiplicativeExprArg
                | MultiplicativeExprArg
                ;

MultiplicativeExprArg : MultiplicativeExprArg MUL UnaryExprArg
                      | MultiplicativeExprArg DIV UnaryExprArg
                      | UnaryExprArg
                      ;

UnaryExprArg : NOT UnaryExprArg
          | MINUS UnaryExprArg %prec UMINUS
          | AMP VariableArg    
          | DEREFERENCE IDENTIFIER 
          | DEREFERENCE ExpressionArg 
          | DEREFERENCE IDENTIFIER LBRACKET INT_LITERAL RBRACKET
          | BAR ExpressionArg BAR
          | PrimaryExprArg
          ;

VariableArg : IDENTIFIER
         | IDENTIFIER LBRACKET ExpressionArg RBRACKET
         ;

PrimaryExprArg : IDENTIFIER
            | INT_LITERAL
            | LPAREN ExpressionArg RPAREN
            | IDENTIFIER LBRACKET ExpressionArg RBRACKET 
            | CHAR_LITERAL 
            | TRUE 
            | FALSE 
            | NULLTOKEN 
            ;

Type : BOOLEAN
     | CHAR
     | INTEGER
     | INTPTR
     | CHARPTR
     ;



/** %token USELESS */

/* %% */
/* 
all : USELESS; */

%%

/** You shall not pass!
 *  You should not  have to do or edit anything past this.
 */

extern int yylineno;

void yyerror(const char *s)
{
    fprintf(stderr, "%s at line %d\n", s, yylineno);
    return;
}
